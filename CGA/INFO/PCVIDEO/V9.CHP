

                         9  Graphics Text


                     Character Definition Tables
                         Video BIOS Support
                Creating a Character Definition Table

                    Software Character Generators
                 Video BIOS Support ş Pixel Handling

              Designing a Software Character Generator
                        Horizontal Alignment
                 Variable Character Sizes ş Clipping
                        Character Orientation
                   Cooperating with the Video BIOS
                     More Power, More Complexity

             Implementing a Software Character Generator
                      CGA ş HGC and HCG+ ş MCGA
                     EGA and VGA ş InColor Card



     Few programs are complete without some sort of text display. Most
     graphics applications incorporate text with graphics images. In
     graphics modes, the software that draws characters requires the same
     thoughtful design and construction as do routines that draw geometric
     figures such as lines and ellipses.

     In alphanumeric video modes, of course, displaying text is easy. You
     simply place a character code and attribute in the video buffer and
     let the hardware character generator put pixels on the screen. In
     graphics modes, however, your program must store every pixel of every
     character in the video buffer.

     This chapter discusses how to translate character codes into the pixel
     patterns that form characters in graphics modes. The programming
     examples are hardware-specific, of course, but you can adapt the
     table-driven character generator described here for use with other
     computers and in other graphics applications.


Character Definition Tables


     Every character that an IBM video subsystem displays is made up of a
     pattern of contiguous pixels. The pixels are arranged to appear as
     coherent, recognizable characters on the screen. The pixel pattern
     that represents a character is the same no matter where in the buffer
     or on the screen the character is located.

     The most convenient way to describe the pixel patterns that represent
     the characters in a character set is to create a table in which bit
     patterns represent the pixel patterns. Such a character definition
     table contains a bit pattern for every displayable character (see
     Figure 9-1). Each character's bit pattern is defined within a
     rectangular matrix. When the character matrix is the same size for all
     characters in the table, and the definitions in the table are
     organized by character code, converting a character code to an offset
     into the table is easy.

     You can use a character definition table formatted in this way in
     alphanumeric as well as graphics modes in video subsystems that
     support RAM-based alphanumeric character definitions. Chapter 10
     covers this topic in detail.


                                           Hex    Binary  ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
                                       ÚÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                                       ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                                       ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA6E  00 00 00 00 00 00 00 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   A5    10100101 ³Û³ ³Û³ ³ ³Û³ ³Û³
FOOO:FA76 ³7E 81 A5 81 BD 99 81 7E                        ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA7E  7E FF DB FF C3 E7 FF 7E     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA86  6C FE FE FE 7C 38 10 00     ³   B0    10111101 ³Û³ ³Û³Û³Û³Û³ ³Û³
FOOO:FA8E  10 38 7C FE 7C 38 10 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA96  38 7C 38 FE FE 7C 38 7C     ³   99    10011001 ³Û³ ³ ³Û³Û³ ³ ³Û³
FOOO:FA9E  10 10 38 7C FE 7C 38 7C     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FAA6  00 00 18 3C 3C 18 00 00     ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FAAE  FF FF E7 C3 C3 E7 FF FF     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                    .                  ÀÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                    .                                     ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
                    .

     Figure 9-1.  The beginning of the bit patterns that define IBM's ROM
     BIOS 8-by-8 character definitions.


Video BIOS Support

     The PC and PS/2 ROM BIOS contains default character definition tables
     for use in graphics modes. The size of the characters in the table
     depends on the vertical resolution of the video mode. In 200-line,
     CGA-compatible video modes, the default character matrix is 8 pixels
     wide and 8 pixels high; in 350-line graphics modes, it is 8 wide by 14
     high; in 400-line and 480-line modes, it is 8 by 16. In all graphics
     modes, the default characters are 8 pixels wide simply because there
     are 8 bits in a byte. Because each byte in a character definition
     table represents 8 horizontal pixels, defining characters as a
     multiple of 8 pixels in width makes the table easy to manipulate in
     software.

     No equivalent constraint applies to the height of characters defined
     in a character definition table. In practice, however, the character
     matrix used with IBM video subsystems should rarely be smaller than 8
     by 6 pixels or larger than 8 by 16 pixels. With a character matrix
     outside this range, the displayed height and width of the characters
     become disproportionate and the characters tend to appear too short or
     too elongated to be easily read.


     Default CGA Characters
     Figure 9-1 shows the beginning of the character definition table for
     the default character set in CGA graphics modes. The table contains an
     8-byte definition for each of the first 128 ASCII characters (0
     through 7FH). The first eight bytes of the table correspond to
     character code 0, the second eight bytes to character code 1, and so
     forth. The bit pattern in each group of eight bytes represents the
     pixel pattern displayed for the corresponding row of pixels in the
     character. The first of the eight bytes in each group corresponds to
     the topmost row of eight pixels.

     This table of 8-by-8 character definitions is located at F000:FA6E in
     the motherboard ROM on all PCs and PS/2s. However, the table defines
     only the first 128 ASCII characters. Character definitions for the
     second group of 128 ASCII codes (80H through 0FFH) are found in a
     table whose address is stored in interrupt vector 1FH (0000:007C).
     Because the motherboard BIOS contains no definitions for these
     characters, the address is initialized to 0000:0000. If you use the
     ROM BIOS to display ASCII characters between 80H and 0FFH in CGA
     graphics modes without pointing this interrupt vector to a character
     definition table, the "characters" you see on the screen are whatever
     binary patterns happen to lie in the first 1024 bytes of RAM.

       ÉÍÍÍ»     The MS-DOS utility GRAFTABL leaves a table of definitions
       º T º     for characters 80H through 0FFH resident in RAM and
       º I º     updates the interrupt 1FH vector to point to it. The
       º P º     characters defined in GRAFTABL are the same as those the
       ÈÍÍÍ¼     alphanumeric character generator displays for ASCII codes
                 80H through 0FFH.


     Default EGA, VGA, and MCGA Characters
     The ROM BIOS in the EGA, VGA, and MCGA subsystems contains definitions
     for all 256 ASCII codes for all graphics modes. (You can access these
     tables directly; their addresses may be obtained by calling INT 10H
     function 11H with AL = 30H.) When you select a graphics mode with INT
     10H function 0, the video BIOS loads the address of the appropriate
     character definition table for the graphics mode into interrupt vector
     43H (0000:010C). In CGA-compatible 200-line graphics modes, the BIOS
     also points the interrupt 1FH vector to the definitions for characters
     80H through  0FFH.


Creating a Character Definition Table

     The easiest way to obtain a character definition table is to use one
     of the default BIOS tables. If the staid, placid characters in those
     tables aren't to your liking, you can find many others commercially
     available or in the public domain.

       ÉÍÍÍ»     Several standard character sets are defined and registered
       º T º     with the International Standards Organization (ISO). IBM
       º I º     refers to these character sets as code pages and has
       º P º     assigned arbitrary identification numbers to them. For
       ÈÍÍÍ¼     example, the standard IBM PC ASCII character set is
                 designated by code page 437; the Canadian French code page
                 is 863; and code page 850 is the general-purpose
                 "multilingual" character set devised by IBM for languages
                 that use a Latin alphabet.

                 Both MS-DOS (starting in version 3.3) and OS/2 allow
                 applications to switch between code pages on an EGA or
                 VGA. When a program displays characters with operating
                 system function calls, the operating system uses the
                 character definitions in the currently selected code page.
                 Applications that use foreign language character sets
                 should, whenever possible, exploit the code pages
                 supported by the operating system.


     When you define your own character set, you can select among several
     alternative methods. The ugly alternative is to build your character
     definition table by specifying every byte in source code. Figure 9-2
     shows the beginning of such a table. A more elegant alternative is to
     use a character-set editing program. With such editors, you use
     cursor-control keys or a pointing device such as a light pen or mouse
     to specify the bit patterns in the table. Character-set editors are
     also available both commercially and in the public domain. (You can
     even write your own, using the routines in this book.)

     Another approach is to start with one of the BIOS character sets and
     transform the bit patterns in a regular way. For example, you could
     reverse the bit patterns in a table by converting 0s to 1s and 1s to
     0s (that is, apply a bitwise logical NOT to each byte in the table),
     thus creating a "reverse" character set.


     CharDefs    db   000h,000h,000h,000h,000h,000h,000h,000h ; character 0
                 db   03Ch,066h,0C0h,0C0h,0C0h,066h,03Ch,000h ; character 1
                 db   0FCh,066h,066h,07Ch,06Ch,066h,0E6h,000h ; character 2
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 3
                 db   078h,0CCh,0CCh,078h,0CCh,0CCh,078h,000h ; character 4
                 db   078h,030h,030h,030h,030h,030h,078h,000h ; character 5
                 db   0CCh,0CCh,0CCh,0CCh,0CCh,078h,030h,000h ; character 6
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 7
                                      .
                                      .
                                      .

     Figure 9-2.  A hand-coded character definition table.


Software Character Generators


     A software routine that uses the bit patterns in a character
     definition table to draw characters in the video buffer is called a
     software character generator. A software character generator performs
     several functions. It locates the bit pattern for a given character
     code, translates the bit pattern into a corresponding pattern of
     pixels, and updates pixels at a specified location in the video
     buffer.


Video BIOS Support

     The video BIOS provides a software character generator that is used
     whenever INT 10H functions 09H, 0AH, 0EH, and 13H are called in
     graphics modes. The software character generator in the IBM PC and AT
     uses only the 8-by-8 characters defined at F000:FA6E and at the
     address indicated by interrupt vector 1FH. The version in the EGA and
     PS/2 BIOS uses the table to which interrupt vector 43H points; this
     version determines the height of displayed characters from the BIOS
     variable POINTS at 0040:0085.

     You can use the BIOS software character generator to display
     characters from any character definition table by updating the
     appropriate interrupt vectors with the address of the table. On the
     EGA and PS/2s, use INT 10H function 11H to do this.

     The BIOS character generator is convenient to use, but it is somewhat
     limited in its capabilities. In particular, it can only store byte-
     aligned characters in the video buffer. If you are willing to
     sacrifice compatibility with the INT 10H interface, you can write a
     faster software character generator that is more powerful than the
     default video BIOS version.


Pixel Handling

     You store characters in the video buffer by changing the values of the
     appropriate pixel groups. You can update the video buffer simply by
     replacing old pixel values with new ones. You can also perform bitwise
     logical operations (AND, OR, or XOR) to update the pixels.

     Your routine to display text in graphics modes can handle the
     background pixels in the character matrix in one of two ways. One is
     to preserve the contents of the video buffer as much as possible by
     updating only foreground pixels; that is, by updating only those
     pixels that represent the character itself (see Figure 9-3a). The
     other is to update all foreground and background pixels within the
     bounds of the rectangular character matrix (see Figure 9-3b).


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-3 is found on page 272       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-3.  Characters written without background pixels (a.) and
     with background pixels (b.).


     Updating only the character's foreground pixels preserves as many
     pixels in the video buffer as possible. This may be the best way to
     display text in front of a detailed or patterned graphics image.
     However, reading the displayed characters can be difficult if the
     graphics image in some way blends with the character. For example,
     text is invisible against a region filled with pixels having the same
     value as the character's foreground pixels.

     To avoid such problems, you can update all foreground and background
     pixels in the character matrix each time you store a character in the
     buffer. This avoids a background pattern inadvertently masking the
     characters. The trade-off is that each time you store a character in
     the buffer you must replace the previous contents of the buffer with a
     rectangular blot.

     The source code for the two types of graphics text routines is
     similar. The examples in this chapter demonstrate the second type,
     which makes them more complicated than routines that draw only
     foreground pixels. You can convert the routines to draw only the
     foreground pixels by eliminating the code for incorporating the
     background pixels.


Designing a Software Character Generator


     Software character generators for IBM PC video subsystems have a
     number of design considerations in common. Because the performance of
     your character generator strongly influences the overall performance
     of many graphics applications, always consider the trade-offs between
     function and simplicity in your character generator routines.


Horizontal Alignment

     In graphics modes, the left edge of a character is not necessarily
     byte-aligned. When a character is written so that its leftmost pixels
     fall somewhere in the middle of a byte in the video buffer (see Figure
     9-4a), the character generator must shift and mask the character
     matrix so that only pixels that are part of the character are updated.

     Usually, however, characters are written into the video buffer at
     byte-aligned pixel addresses (see Figure 9-4b). This is the case, for
     example, whenever the display is used in a "teletype mode"; that is,
     when each line of characters starts at the left edge of the display.
     Generating byte-aligned characters requires no rotation or masking of
     pixels, so using a separate routine for byte-aligned characters
     improves the character generator's performance.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-4 is found on page 273       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-4.  Alignment of characters in the video buffer. In Figure
     9-4a, characters are not aligned; in Figure 9-4b, characters are byte-
     aligned.


Variable Character Sizes

     Writing a character generator that accommodates characters of
     different heights is relatively easy. The height of a character
     corresponds to the number of bytes in its definition in the character
     definition table. You can thus use the height of your characters as a
     loop limit inside the character generator routine without
     significantly affecting the complexity of the routine.

     Handling characters of different widths is more difficult. If the
     width of a character does not fit exactly into an integer number of
     bytes, you must mask each row of pixels in the character as you store
     it in the video buffer. Again, the extra overhead of forming the
     appropriate bit mask and masking pixels in the video buffer
     complicates and slows the character generator routine.


Clipping

     You can clip characters in several ways. The simplest is to clip the
     entire character before you store it in the video buffer; if any
     portion of the character matrix would lie outside the clipping area,
     don't write the character.

     Clipping a character so that only a portion of it is stored in the
     video buffer is more difficult. One way to do this is to modify the
     character generator so that any clipped portion of a character is not
     written to the buffer. Another approach is to write the entire
     character into an auxiliary buffer and then copy the clipped character
     into the video buffer with a pixel block copy routine (see Chapter
     11).


Character Orientation

     Usually, characters are displayed so that they can be read from left
     to right and from the top down. To change this orientation, apply the
     appropriate transformation to the bit patterns in the character
     definition table. For example, the subroutine in Listing 9-1 rotates
     the 8-byte bit pattern that represents an 8-by-8 character so that the
     displayed characters read upward. With this transformation, you can
     use the same character generator to display vertically or horizontally
     oriented characters. Only the bit patterns differ.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-1.  A routine that rotates an 8-by-8 character
     definition by 90 degrees.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Cooperating with the Video BIOS

     Even if your character definition tables and character generator
     software avoid using video BIOS functions, you should nevertheless try
     to preserve compatibility by cooperating with the BIOS routines when
     possible. In 200-line graphics modes, you should update the address in
     interrupt vector 1FH whenever you use an 8-by-8 character definition
     table that includes the second 128 ASCII characters. On the EGA, VGA,
     and MCGA, you should generally use INT 10H function 11H to keep the
     BIOS interrupt vectors and Video Display Data Area variables up to
     date.


More Power, More Complexity

     You can add functionality to a software character generator in several
     ways. You might, for example, write a character generator that refers
     to a table of relative character widths to display proportionally
     spaced characters. As your routine reads bit patterns from the
     character definition table, you might have it shift them to the right
     by a predetermined number of pixels to generate bold or italic
     character sets. You might apply a pattern of pixel values to the
     foreground pixels you update. You might allow a character definition
     table to extend beyond the usual range of 256 characters; the more
     characters you define, the wider range of characters you can display
     at one time. Any of these possibilities adds power and flexibility to
     your software character generator, but all of them complicate your
     source code and ultimately slow it down.


Implementing a Software Character Generator


     All software character generator examples in this chapter require that
     you specify the x- and y-coordinates of the pixel in the upper left
     corner of the displayed character matrix. Each routine detects the
     special case where the character matrix is byte-aligned in the video
     buffer, but the routines do not validate pixel coordinates or perform
     any clipping. All the routines except DisplayChar10() update pixels in
     the video buffer by replacing their values. To perform a bitwise AND,
     OR, or XOR operation, you must modify the routines (see Chapter 5).


CGA

     In 640-by-200 2-color mode on the CGA, the software character
     generator applies the bit patterns in the character definition table
     directly to the pixels in the video buffer (see Listing 9-2). When
     the character is byte-aligned in the video buffer, the routine copies
     pixel values directly from the character definition table. Otherwise,
     for each row of eight pixels in the character, a rotated 16-bit mask
     is used to zero the proper eight pixels in the buffer. Then the pixels
     from the character definition table are rotated into position and
     stored in the buffer using a bitwise OR operation.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-2.  A software character generator for 640-by-200 2-color
     mode.

                TITLE   'Listing 9-3'
                NAME    DisplayChar06
                PAGE    55,132

;
; Name:         DisplayChar06
;
; Function:     Display a character in 640x200 2-color mode
;
; Caller:       Microsoft C:
;
;                       void DisplayChar06(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

VARmask         EQU     [bp-2]
VARtoggle       EQU     [bp-4]


_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr06:near

                PUBLIC  _DisplayChar06
_DisplayChar06  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,4            ; stack space for local variables
                push    si
                push    di
                push    ds

; set up foreground pixel toggle mask

                mov     ah,ARGfgd       ; AH := 0 or 1 (foreground pixel value)
                ror     ah,1            ; high-order bit of AH := 0 or 1
                cwd                     ; propagate high-order bit through DX
                not     dx              ; DX :=     0 if foreground = 1
                                        ;    or FFFFh if foreground = 0
                mov     VARtoggle,dx

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddr06     ; ES:BX -> buffer
                                        ; CL := # bits to shift left

                xor     cl,7            ; CL := # bits to rotate right

                mov     ax,0FF00h
                ror     ax,cl           ; AX := bit mask in proper position
                mov     VARmask,ax

; set up video buffer addressing

                mov     dx,2000h        ; increment for video buffer interleave
                mov     di,80-2000h     ; increment from last to first interleave

                test    bx,2000h        ; set zero flag if BX in 1st interleave
                jz      L01

                xchg    di,dx           ; exchange increment values if 1st pixel
                                        ;  lies in 1st interleave

; set up character definition table addressing

L01:            push    bx              ; preserve buffer address

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area
                mov     ch,ds:[85h]     ; CH := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                cmp     al,80h
                jae     L02

                mov     bx,43h*4        ; DS:BX -> int 43h vector if char < 80h
                jmp     short L03

L02:            mov     bx,1Fh*4        ; DS:BX -> int 1Fh vector if char >= 80h
                sub     al,80h          ; put character code in range of table 

L03:            lds     si,ds:[bx]      ; DS:SI -> start of character table
                mul     ch              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     si,ax           ; SI := addr of char def

                pop     bx              ; restore buffer address

                test    cl,cl           ; test # bits to rotate
                jnz     L20             ; jump if character is not byte-aligned


; routine for byte-aligned characters

                mov     ah,VARtoggle    ; AH := foreground toggle mask
                xchg    ch,cl           ; CX := POINTS
                
L10:            lodsb                   ; AL := bit pattern for next pixel row
                xor     al,ah           ; toggle pixels if foreground = 0
                mov     es:[bx],al      ; store pixels in buffer

                add     bx,dx           ; BX := next row in buffer
                xchg    di,dx           ; swap buffer increments
                loop    L10
                jmp     short Lexit


; routine for non-byte-aligned characters

L20:            mov     ax,VARmask
                and     es:[bx],ax      ; mask character pixels in buffer

                xor     ah,ah
                lodsb                   ; AX := bit pattern for next pixel row
                xor     al,VARtoggle    ; toggle pixels if foreground = 0

                ror     ax,cl           ; rotate pixels into position
                or      es:[bx],ax      ; store pixels in buffer

                add     bx,dx           ; BX := next row in buffer
                xchg    di,dx           ; swap buffer increments
                dec     ch
                jnz     L20


Lexit:          pop     ds              ; restore registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayChar06  ENDP

_TEXT           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routine for 320-by-200 4-color mode in Listing 9-3 is more
     complicated because each bit in the character definition must be
     expanded into the appropriate 2-bit pixel value. A 0 bit in the
     character definition table becomes a 2-bit background pixel value; a
     1 bit in the table is expanded into a 2-bit foreground pixel value.
     Thus, each byte in the table is transformed into a word of pixels.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-3.  A software character generator for 640-by-200
     4-color mode.

                TITLE   'Listing 9-3'
                NAME    DisplayChar04
                PAGE    55,132

;
; Name:         DisplayChar04
;
; Function:     Display a character in 320x200 4-color graphics mode
;
; Caller:       Microsoft C:
;
;                       void DisplayChar04(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU              [bp+10]
ARGbkgd         EQU              [bp+12]

VARshift        EQU     word ptr [bp-2]
VARincr         EQU     word ptr [bp-4]


DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                EXTRN   PixelAddr04:near

                PUBLIC  _DisplayChar04
_DisplayChar04  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,4            ; stack space for local variables
                push    si
                push    di
                push    ds

; propagate pixel values

                mov     bx,offset DGROUP:PropagatedPixel
                mov     al,ARGfgd
                xlat                    ; propagate foreground pixel value
                mov     ah,al
                mov     ARGfgd,ax

                mov     al,ARGbkgd
                xlat                    ; propagate background pixel value
                mov     ah,al
                mov     ARGbkgd,ax 

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddr04     ; ES:BX -> buffer
                                        ; CL := # bits to shift left
                                        ;  to mask pixel
                mov     ch,0FCh
                shl     ch,cl           ; CH := bit mask for right side of char

                xor     cl,6            ; CL := 6 - CL (# bits to rotate char
                                        ;  into position)
                mov     VARshift,cx

; set up video buffer addressing

                mov     di,2000h        ; increment for video buffer interleave
                mov     VARincr,80-2000h ; increment from last to first interleave

                test    bx,2000h        ; set zero flag if BX in 1st interleave
                jz      L01

                xchg    VARincr,di      ; exchange increment values if 1st pixel
                                        ;  lies in 1st interleave

; set up character definition table addressing

L01:            push    bx              ; preserve buffer address

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area
                mov     ch,ds:[85h]     ; CH := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                cmp     al,80h
                jae     L02

                mov     bx,43h*4        ; DS:BX -> int 43h vector if char < 80h
                jmp     short L03

L02:            mov     bx,1Fh*4        ; DS:BX -> int 1Fh vector if char >= 80h
                sub     al,80h          ; put character code in range of table 

L03:            lds     si,ds:[bx]      ; DS:SI -> start of character table
                mul     ch              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     si,ax           ; SI := addr of char def

                pop     bx              ; restore buffer address

                xchg    ch,cl           ; CH := # bits to rotate
                                        ; CL := POINTS
                
                test    ch,ch           ; test # bits to rotate
                jnz     L20             ; jump if character is not byte-aligned


; routine for byte-aligned characters

L10:            lodsb                   ; AL := bit pattern for next pixel row
                xor     dx,dx           ; DX := initial value for doubled bits
                mov     ah,8            ; AH := # of bits in pattern

L11:            shr     al,1            ; cf := lo-order bit of AL
                rcr     dx,1            ; hi-order bit of CX := cf
                sar     dx,1            ; double hi-order bit of DX
                dec     ah              ; loop 8 times
                jnz     L11

                mov     ax,dx           ; AX,DX := doubled bit pattern
                and     ax,ARGfgd       ; AX := foreground pixels
                not     dx
                and     dx,ARGbkgd      ; DX := background pixels

                or      ax,dx           ; AX := eight pixels
                xchg    ah,al           ; put bytes in proper order
                mov     es:[bx],ax      ; update video buffer

                add     bx,di           ; BX := next row in buffer
                xchg    di,VARincr      ; swap buffer increments

                loop    L10
                jmp     short Lexit


; routine for non-byte-aligned characters

L20:            xor     ch,ch           ; CX := POINTS

L21:            push    cx              ; preserve CX

                mov     cx,VARshift     ; CH := mask for right side of char
                                        ; CL := # bits to rotate

                lodsb                   ; AL := bit pattern for next pixel row
                xor     dx,dx           ; DX := initial value for doubled bits
                mov     ah,8            ; AH := # of bits in pattern

L22:            shr     al,1            ; DX := double bits in AL
                rcr     dx,1            ;  (same as above)
                sar     dx,1
                dec     ah
                jnz     L22

                xchg    dh,dl           ; DH := bits for right half of char
                                        ; DL := bits for left half of char
                mov     ax,dx
                and     ax,ARGfgd       ; AX := foreground pixels
                not     dx
                and     dx,ARGbkgd      ; DX := background pixels

                or      dx,ax           ; DX := eight pixels
                ror     dx,cl           ; DH := left and right side pixels
                                        ; DL := middle pixels
                mov     al,ch
                xor     ah,ah           ; AX := mask for left and middle
                                        ;  bytes of char
                and     es:[bx],ax      ; zero pixels in video buffer

                not     ax
                and     ax,dx
                or      es:[bx],ax      ; update pixels in left and middle bytes

                mov     al,ch           ; AL := mask for right-hand byte
                not     al
                and     es:[bx+2],al    ; mask pixels in right-hand byte in buffer
                and     ch,dl
                or      es:[bx+2],ch    ; update pixels in right-hand byte

                add     bx,di           ; BX := next row in buffer
                xchg    di,VARincr      ; swap buffer increments

                pop     cx              ; restore CX
                loop    L21


Lexit:          pop     ds              ; restore registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayChar04  ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

PropagatedPixel DB      00000000b       ; 0
                DB      01010101b       ; 1
                DB      10101010b       ; 2
                DB      11111111b       ; 3

_DATA           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In Listing 9-3, when the character is byte-aligned in the video
     buffer, the routine moves the 16-bit word of pixels directly into the
     buffer. A character that is not byte-aligned spans three bytes in the
     buffer. In this case, the routine must rotate the eight pixels in each
     row of the character into position. Then the first two bytes of the
     character in the buffer are masked and updated, followed by the third
     (rightmost) byte of the character.


HGC and HGC+

     A routine for the 720-by-348 monochrome graphics mode on the HGC and
     the HGC+ can use the same bit-masking technique that the CGA 640-by-
     200 2-color routine uses. You could convert DisplayChar06() into a
     Hercules-compatible routine by revising the call to PixelAddr06() and
     by changing video buffer addressing to accommodate the different
     buffer interleaves on the two adapters.

     It is worthwhile, however, to exploit the HGC's 720-pixel horizontal
     resolution by displaying characters in a matrix that is 9 pixels wide,
     so that each row on the screen contains 80 evenly spaced characters.
     The routine in Listing 9-4 does this by appending a ninth bit to each
     8-bit pattern it reads from the character definition table. The
     ninth bit is 0 except for box-drawing characters (ASCII 0C0-0DFH).
     For these characters, the ninth bit is a copy of the rightmost
     bit in the bit pattern. (This mimics the function of the hardware
     character generator in alphanumeric modes. See Chapter 10.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-4.  A software character generator for Hercules monochrome
     graphics mode.

                TITLE   'Listing 9-4'
                NAME    DisplayCharHGC
                PAGE    55,132

;
; Name:         DisplayCharHGC
;
; Function:     Display a character in Hercules 720x348 monochrome graphics mode
;
; Caller:       Microsoft C:
;
;                       void DisplayCharHGC(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

VARmask         EQU              [bp-2]
VARtoggle       EQU              [bp-4]
VAR9bits        EQU     byte ptr [bp-6]


_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddrHGC:near

                PUBLIC  _DisplayCharHGC
_DisplayCharHGC PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,6            ; stack space for local variables
                push    si
                push    di
                push    ds

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddrHGC    ; ES:BX -> buffer
                                        ; CL := # bits to shift left

                xor     cl,7            ; CL := # bits to rotate right

; set up 8- or 9-bit mask

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area

                mov     ax,0FF00h       ; AX := 8-bit mask
                mov     VAR9bits,0      ; zero this flag

                cmp     byte ptr ds:[4Ah],90    ; does CRT_COLS = 90?
                je      L01             ; jump if characters are 8 pixels wide

                mov     ah,7Fh          ; AX := 9-bit mask
                cmp     ARGc,0C0h
                jb      L01             ; jump if character code ...

                cmp     ARGc,0DFh
                ja      L01             ; ... outside of range 0C0-0DFh

                inc     VAR9bits        ; set flag to extend to 9 bits

L01:            ror     ax,cl           ; AX := bit mask in proper position
                mov     VARmask,ax

; set up foreground pixel toggle mask

                mov     ah,ARGfgd       ; AH := 0 or 1 (foreground pixel value)
                ror     ah,1            ; high-order bit of AH := 0 or 1
                cwd                     ; propagate high-order bit through DX
                not     dx              ; DX :=     0 if foreground = 1
                                        ;    or FFFFh if foreground = 0
                mov     ax,VARmask
                not     ax
                and     dx,ax           ; zero unused bits of toggle mask in DX
                mov     VARtoggle,dx

; set up character definition table addressing

                push    bx              ; preserve buffer address

                mov     ch,ds:[85h]     ; CH := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                cmp     al,80h
                jae     L02

                mov     bx,43h*4        ; DS:BX -> int 43h vector if char < 80h
                jmp     short L03

L02:            mov     bx,1Fh*4        ; DS:BX -> int 1Fh vector if char >= 80h
                sub     al,80h          ; put character code in range of table 

L03:            lds     si,ds:[bx]      ; DS:SI -> start of character table
                mul     ch              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     si,ax           ; SI := addr of char def

                pop     bx              ; restore buffer address

; mask and set pixels in the video buffer

L20:            mov     ax,VARmask
                and     es:[bx],ax      ; mask character pixels in buffer

                xor     ah,ah
                lodsb                   ; AX := bit pattern for next pixel row
                cmp     VAR9bits,0
                je      L21             ; jump if character is 8 pixels wide

                ror     ax,1            ; copy lo-order bit of AX into ...
                rcl     al,1            ;  hi-order bit

L21:            ror     ax,cl           ; rotate pixels into position
                xor     ax,VARtoggle    ; toggle pixels if foreground = 0
                or      es:[bx],ax      ; store pixels in buffer

                add     bx,2000h        ; increment to next portion of interleave
                jns     L22

                add     bx,90-8000h     ; increment to first portion of interleave

L22:            dec     ch
                jnz     L20


Lexit:          pop     ds              ; restore registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayCharHGC ENDP

_TEXT           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Note how the CGA and Hercules routines use interrupt
       º T º     vector 43H to point to the start of the current character
       º I º     definition table. This is the interrupt vector the EGA and
       º P º     VGA ROM BIOS uses for this purpose. Also, the routines
       ÈÍÍÍ¼     determine the size of the displayed character matrix by
                 inspecting the variables POINTS (0040:0085) and CRT_COLS
                 (0040:004A) in the BIOS Video Display Data Area. If you
                 are not using an EGA, MCGA, or VGA, the BIOS won't keep
                 the interrupt vector and POINTS up to date; in this case,
                 your program should either update these values explicitly
                 or maintain equivalent values elsewhere.


MCGA

     In 640-by-480 2-color mode on the MCGA, pixels are stored eight to a
     byte, so you can adapt the 640-by-200 2-color character generator for
     use in this mode by modifying its video buffer addressing. A character
     generator for 320-by-200 256-color mode is a little different, because
     each bit in the character definition table expands into a byte in the
     video buffer (see Listing 9-5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-5.  A character generator for MCGA and VGA 320-by-200 256-
     color mode.

                TITLE   'Listing 9-5'
                NAME    DisplayChar13
                PAGE    55,132

;
; Name:         DisplayChar13
;
; Function:     Display a character in MCGA/VGA 320x200 256-color mode
;
; Caller:       Microsoft C:
;
;                       void DisplayChar13(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

BytesPerLine    EQU     320

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr13:near

                PUBLIC  _DisplayChar13
_DisplayChar13  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si
                push    di
                push    ds

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddr13     ; ES:BX -> buffer
                mov     di,bx           ; ES:DI -> buffer

; set up character definition table addressing

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area
                mov     cx,ds:[85h]     ; CX := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                mov     bx,43h*4        ; DS:BX -> int 43h vector if char < 80h
                lds     si,ds:[bx]      ; DS:SI -> start of character table
                mul     cl              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     si,ax           ; SI := addr of char def
                
; store the character in the video buffer

                mov     bl,ARGfgd       ; BL := foreground pixel value
                mov     bh,ARGbkgd      ; BH := background pixel value

L10:            push    cx              ; preserve CX across loop
                mov     cx,8            ; CX := character width in pixels
                lodsb
                mov     ah,al           ; AH := bit pattern for next pixel row

L11:            mov     al,bl           ; AL := foreground pixel value
                shl     ah,1            ; carry flag := high-order bit
                jc      L12             ; jump if bit pattern specifies a
                                        ;  foreground pixel (bit = 1)
                mov     al,bh           ; AL := background pixel value

L12:            stosb                   ; update one pixel in the buffer
                loop    L11

                add     di,BytesPerLine-8 ; increment buffer address to next
                                          ;  row of pixels
                pop     cx
                loop    L10             ; loop down character

                pop     ds              ; restore registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayChar13  ENDP

_TEXT           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


EGA and VGA

     The routine for the EGA and VGA in Listing 9-6 uses the Graphics
     Controller to update pixels in the video buffer. The routine is
     similar in some ways to the routine for the CGA's 640-by-200 2-color
     mode, because each byte of the video buffer represents eight pixels.
     Of course, the code is complicated by the need to program the Graphics
     Controller to handle the foreground and background pixel values.

     The routine writes each row of pixels in the character by latching the
     bit planes, updating the foreground pixels, updating the background
     pixels, and then writing the latches back to the bit planes. The
     Graphics Controller cannot conveniently update both foreground and
     background pixels at the same time, so the routine must perform these
     operations separately.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-6.  A software character generator for native EGA and VGA
     graphics modes.

                TITLE   'Listing 9-6'
                NAME    DisplayChar10
                PAGE    55,132

;
; Name:         DisplayChar10
;
; Function:     Display a character in native EGA and VGA graphics modes
;
; Caller:       Microsoft C:
;
;                       void DisplayChar10(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

VARshift        EQU              [bp-2]

BytesPerLine    =       80              ; (must 40 in 320x200 16-color mode)
RMWbits         =       18h             ; Read-Modify-Write bits

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr10:near

                PUBLIC  _DisplayChar10
_DisplayChar10  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,2            ; stack space for local variable
                push    si
                push    di
                push    ds

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddr10     ; ES:BX -> buffer
                                        ; CL := # bits to shift left to mask
                                        ;  pixel
                inc     cx
                and     cl,7            ; CL := # bits to shift to mask char

                mov     ch,0FFh
                shl     ch,cl           ; CH := bit mask for right side of char
                mov     VARshift,cx

                push    es              ; preserve video buffer segment
                mov     si,bx           ; SI := video buffer offset

; set up character definition table addressing

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area
                mov     cx,ds:[85h]     ; CX := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                mov     bx,43h*4        ; DS:BX -> int 43h vector
                les     di,ds:[bx]      ; ES:DI -> start of character table
                mul     cl              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     di,ax           ; DI := addr of char def

                pop     ds              ; DS:SI -> video buffer

; set up Graphics Controller registers

                mov     dx,3CEh         ; Graphics Controller address reg port

                mov     ax,0A05h        ; AL :=  Mode register number
                                        ; AH :=  Write Mode 2 (bits 0-1)
                                        ;        Read Mode 1 (bit 4)
                out     dx,ax

                mov     ah,RMWbits      ; AH := Read-Modify-Write bits
                mov     al,3            ; AL := Data Rotate/Function Select reg
                out     dx,ax

                mov     ax,0007         ; AH := Color Don't Care bits
                                        ; AL := Color Don't Care reg number
                out     dx,ax           ; "don't care" for all bit planes 

; select output routine depending on whether character is byte-aligned

                mov     bl,ARGfgd       ; BL := foreground pixel value
                mov     bh,ARGbkgd      ; BH := background pixel value

                cmp     byte ptr VARshift,0   ; test # bits to shift
                jne     L20             ; jump if character is not byte-aligned


; routine for byte-aligned characters

                mov     al,8            ; AL := Bit Mask register number 

L10:            mov     ah,es:[di]      ; AH := pattern for next row of pixels
                out     dx,ax           ; update Bit Mask register
                and     [si],bl         ; update foreground pixels

                not     ah
                out     dx,ax
                and     [si],bh         ; update background pixels

                inc     di              ; ES:DI -> next byte in char def table
                add     si,BytesPerLine ; increment to next line in video buffer
                loop    L10
                jmp     short Lexit


; routine for non-byte-aligned characters

L20:            push    cx              ; preserve loop counter
                mov     cx,VARshift     ; CH := mask for left side of character
                                        ; CL := # bits to shift left
; left side of character

                mov     al,es:[di]      ; AL := bits for next row of pixels
                xor     ah,ah
                shl     ax,cl           ; AH := bits for left side of char
                                        ; AL := bits for right side of char
                push    ax              ; save bits for right side on stack
                mov     al,8            ; AL := Bit Mask Register number
                out     dx,ax           ; set bit mask for foreground pixels

                and     [si],bl         ; update foreground pixels

                not     ch              ; CH := mask for left side of char
                xor     ah,ch           ; AH := bits for background pixels
                out     dx,ax           ; set bit mask

                and     [si],bh         ; update background pixels

; right side of character

                pop     ax
                mov     ah,al           ; AH := bits for right side of char
                mov     al,8
                out     dx,ax           ; set bit mask

                inc     si              ; DS:SI -> right side of char in buffer

                and     [si],bl         ; update foreground pixels

                not     ch              ; CH := mask for right side of char
                xor     ah,ch           ; AH := bits for background pixels
                out     dx,ax           ; set bit mask

                and     [si],bh         ; update background pixels

; increment to next row of pixels in character

                inc     di              ; ES:DI -> next byte in char def table
                dec     si
                add     si,BytesPerLine ; DS:SI -> next line in video buffer

                pop     cx
                loop    L20


; restore default Graphics Controller registers

Lexit:          mov     ax,0FF08h       ; default Bit Mask
                out     dx,ax

                mov     ax,0005         ; default Mode register
                out     dx,ax

                mov     ax,0003         ; default Data Rotate/Function Select
                out     dx,ax

                mov     ax,0F07h        ; default Color Don't Care
                out     dx,ax

                pop     ds              ; restore caller registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayChar10  ENDP

_TEXT           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


InColor Card

     The technique for storing characters in the video buffer on the
     Hercules InColor Card, shown in Listing 9-7, is different from that
     on the EGA or VGA because you can use the InColor Card's Read/Write
     Color register (1AH) and write mode 0 to update both foreground and
     background pixel values in one operation. Thus, the actual process of
     updating the bit planes collapses into relatively few machine
     instructions.

     However, the InColor Card cannot perform pixel AND, OR, or XOR
     operations in hardware. To do this, you must write additional
     subroutines that use the Plane Mask register to map logical operations
     onto the bit planes (see Chapter 5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-7.  A software character generator for Hercules InColor
     graphics modes.

                TITLE   'Listing 9-7'
                NAME    DisplayCharInC
                PAGE    55,132

;
; Name:         DisplayCharInC
;
; Function:     Display a character in InColor 720x348 16-color mode
;
; Caller:       Microsoft C:
;
;                       void DisplayCharInC(c,x,y,fgd,bkgd);
;
;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and background
;                                                   pixel values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

VARmask         EQU     word ptr [bp-2]
VAR9bits        EQU     byte ptr [bp-4]

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddrHGC:near

                PUBLIC  _DisplayCharInC
_DisplayCharInC PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,4            ; stack space for local variables
                push    si
                push    di
                push    ds

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddrHGC    ; ES:BX -> buffer
                                        ; CL := # bits to shift left to mask
                                        ;  pixel
                xor     cl,7            ; CL := # bits to rotate right

                push    es              ; preserve video buffer segment
                mov     si,bx           ; DI := video buffer offset

; set up flag for 8- or 9-bit characters

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area

                mov     ax,0FF00h       ; AX := 8-bit mask
                mov     VAR9bits,0      ; zero this flag

                cmp     byte ptr ds:[4Ah],90    ; does CRT_COLS = 90?
                je      L01             ; jump if characters are 8 pixels wide

                mov     ah,7Fh          ; AX := 9-bit mask
                cmp     ARGc,0C0h
                jb      L01             ; jump if character code ...

                cmp     ARGc,0DFh
                ja      L01             ; ... outside of range 0C0-0DFh

                inc     VAR9bits        ; set flag to extend to 9 bits

L01:            ror     ax,cl           ; AX := bit mask in proper position
                mov     VARmask,ax

; set up character definition table addressing

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;  Display Data area
                mov     ch,ds:[85h]     ; CH := POINTS (pixel rows in character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                cmp     al,80h
                jae     L02

                mov     bx,43h*4        ; DS:BX -> int 43h vector if char < 80h
                jmp     short L03

L02:            mov     bx,1Fh*4        ; DS:BX -> int 1Fh vector if char >= 80h
                sub     al,80h          ; put character code in range of table 

L03:            les     di,ds:[bx]      ; ES:DI -> start of character table
                mul     ch              ; AX := offset into char def table
                                        ;  (POINTS * char code)
                add     di,ax           ; DI := addr of char def

                pop     ds              ; DS:SI -> video buffer

; set up control registers

                mov     dx,3B4h         ; control register I/O port

                push    cx              ; preserve CX
                mov     ah,ARGbkgd      ; AH := background pixel value
                mov     cl,4
                shl     ah,cl           ; AH bits 4-7 := background pixel value
                or      ah,ARGfgd       ; AH bits 0-3 := foreground pixel value
                pop     cx              ; restore CX

                mov     al,1Ah          ; AL := Read/Write Color reg number
                out     dx,ax           ; set Read/Write Color value

; mask and set pixels in the video buffer

L20:            xor     bh,bh
                mov     bl,es:[di]      ; BX := bit pattern for next pixel row
                inc     di              ; increment pointer to char def table
                cmp     VAR9bits,0

                je      L21             ; jump if character is 8 pixels wide

                ror     bx,1            ; copy lo-order bit of BX into ...
                rcl     bl,1            ;  hi-order bit

L21:            ror     bx,cl           ; rotate pixels into position

                mov     ax,5F19h        ; AH bit 6 := 1 (mask polarity)
                                        ; AH bits 4-5 := 01b (write mode 1)
                                        ; AH bits 0-3 := 1111b (don't care bits)
                                        ; AL := 19h (Read/Write Control reg)
                out     dx,ax           ; set up Read/Write control reg

                or      [si],bl         ; update foreground pixels
                or      [si+1],bh

                mov     ah,6Fh          ; set up write mode 2
                out     dx,ax

                or      bx,VARmask      ; BX := background pixel bit pattern
                or      [si],bl         ; update background pixels
                or      [si+1],bh

                add     si,2000h        ; increment to next portion of interleave
                jns     L22

                add     si,90-8000h     ; increment to first portion of interleave

L22:            dec     ch
                jnz     L20

; restore default InColor register values

                mov     ax,4019h        ; default Read/Write Control reg
                out     dx,ax

                mov     ax,071Ah        ; default Read/Write Color reg
                out     dx,ax

                pop     ds              ; restore registers and return
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisplayCharInC ENDP

_TEXT           ENDS

                END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
